{"version":3,"sources":["../src/utils.js"],"names":["uint32_to_buf","buf_to_uint32","uint8_to_buf","hex_to_buf","buf_to_hex","path_to_buf","chunkBy","stripRetcodeFromResponse","buf_to_amount","amount_to_buf","base58_encode","base58_decode","str_to_path","BASE58_ALPHABET","bs58","HARDENED","bs10","MAX_LOVELACE_SUPPLY_STR","join","Precondition","check","cond","Error","checkIsString","data","checkIsInteger","Number","isInteger","checkIsArray","Array","isArray","checkIsBuffer","Buffer","isBuffer","checkIsUint32","checkIsUint8","checkIsHexString","length","test","checkIsValidPath","path","x","checkIsValidAmount","amount","checkIsValidBase58","c","includes","Assert","assert","value","alloc","writeUInt32BE","readUIntBE","writeUInt8","from","toString","i","sum","arr","reduce","y","chunkLengths","len","offset","result","restLength","push","slice","response","L","retcode","encoded","encode","replace","decode","padding","concat","safe_parseInt","str","parseInt","isNaN","parseBIP32Index","base","endsWith","split","map"],"mappings":"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","file":"utils.js","sourcesContent":["//@flow\nimport basex from \"base-x\";\n\nconst BASE58_ALPHABET =\n  \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nconst bs58 = basex(BASE58_ALPHABET);\n\nconst HARDENED = 0x80000000;\n\n// We use bs10 as an easy way to parse/encode amount strings\nconst bs10 = basex(\"0123456789\");\n\n// Max supply in lovelace\nconst MAX_LOVELACE_SUPPLY_STR = [\"45\", \"000\", \"000\", \"000\", \"000000\"].join(\"\");\n\nexport const Precondition = {\n  // Generic check\n  check: (cond: boolean) => {\n    if (!cond) throw new Error(\"Precondition failed\");\n  },\n  // Basic types\n  checkIsString: (data: any) => {\n    Precondition.check(typeof data === \"string\");\n  },\n  checkIsInteger: (data: any) => {\n    Precondition.check(Number.isInteger(data));\n  },\n  checkIsArray: (data: any) => {\n    Precondition.check(Array.isArray(data));\n  },\n  checkIsBuffer: (data: any) => {\n    Precondition.check(Buffer.isBuffer(data));\n  },\n\n  // Extended checks\n  checkIsUint32: (data: any) => {\n    Precondition.checkIsInteger(data);\n    Precondition.check(data >= 0);\n    Precondition.check(data <= 4294967295);\n  },\n  checkIsUint8: (data: any) => {\n    Precondition.checkIsInteger(data);\n    Precondition.check(data >= 0);\n    Precondition.check(data <= 255);\n  },\n\n  checkIsHexString: (data: any) => {\n    Precondition.checkIsString(data);\n    Precondition.check(data.length % 2 == 0);\n    Precondition.check(/^[0-9a-fA-F]*$/.test(data));\n  },\n  checkIsValidPath: (path: Array<number>) => {\n    Precondition.checkIsArray(path);\n    for (const x of path) {\n      Precondition.checkIsUint32(x);\n    }\n  },\n  checkIsValidAmount: (amount: string) => {\n    Precondition.checkIsString(amount);\n    Precondition.check(/^[0-9]*$/.test(amount));\n    // Length checks\n    Precondition.check(amount.length > 0);\n    Precondition.check(amount.length <= MAX_LOVELACE_SUPPLY_STR.length);\n    // Leading zeros\n    if (amount.length > 1) {\n      Precondition.check(amount[0] != \"0\");\n    }\n    // less than max supply\n    if (amount.length == MAX_LOVELACE_SUPPLY_STR.length) {\n      // Note: this is string comparison!\n      Precondition.check(amount <= MAX_LOVELACE_SUPPLY_STR);\n    }\n  },\n  checkIsValidBase58: (data: string) => {\n    Precondition.checkIsString(data);\n    for (const c of data) {\n      Precondition.check(BASE58_ALPHABET.includes(c));\n    }\n  }\n};\n\nexport const Assert = {\n  assert: (cond: boolean) => {\n    if (!cond) throw new Error(\"Assertion failed\");\n  }\n};\n\nexport function uint32_to_buf(value: number): Buffer {\n  Precondition.checkIsUint32(value);\n\n  const data = Buffer.alloc(4);\n  data.writeUInt32BE(value, 0);\n  return data;\n}\n\nexport function buf_to_uint32(data: Buffer): number {\n  Precondition.check(data.length == 4);\n\n  return data.readUIntBE(0, 4);\n}\n\nexport function uint8_to_buf(value: number): Buffer {\n  Precondition.checkIsUint8(value);\n\n  const data = Buffer.alloc(1);\n  data.writeUInt8(value, 0);\n  return data;\n}\n\nexport function hex_to_buf(data: string): Buffer {\n  Precondition.checkIsHexString(data);\n  return Buffer.from(data, \"hex\");\n}\n\nexport function buf_to_hex(data: Buffer): string {\n  return data.toString(\"hex\");\n}\n\n// no buf_to_uint8\n\nexport function path_to_buf(path: Array<number>): Buffer {\n  Precondition.checkIsValidPath(path);\n\n  const data = Buffer.alloc(1 + 4 * path.length);\n  data.writeUInt8(path.length, 0);\n\n  for (let i = 0; i < path.length; i++) {\n    data.writeUInt32BE(path[i], 1 + i * 4);\n  }\n  return data;\n}\n\nconst sum = (arr: Array<number>) => arr.reduce((x, y) => x + y, 0);\n\nexport function chunkBy(data: Buffer, chunkLengths: Array<number>) {\n  Precondition.checkIsBuffer(data);\n  Precondition.checkIsArray(chunkLengths);\n  for (const len of chunkLengths) {\n    Precondition.checkIsInteger(len);\n    Precondition.check(len > 0);\n  }\n  Precondition.check(data.length <= sum(chunkLengths));\n\n  let offset = 0;\n  const result = [];\n\n  const restLength = data.length - sum(chunkLengths);\n\n  for (let c of [...chunkLengths, restLength]) {\n    result.push(data.slice(offset, offset + c));\n\n    offset += c;\n  }\n\n  return result;\n}\n\nexport function stripRetcodeFromResponse(response: Buffer): Buffer {\n  Precondition.checkIsBuffer(response);\n  Precondition.check(response.length >= 2);\n\n  const L = response.length - 2;\n  const retcode = response.slice(L, L + 2);\n\n  if (retcode.toString(\"hex\") != \"9000\")\n    throw new Error(`Invalid retcode ${retcode.toString(\"hex\")}`);\n  return response.slice(0, L);\n}\n\nexport function buf_to_amount(data: Buffer): string {\n  Precondition.checkIsBuffer(data);\n  Precondition.check(data.length == 8);\n\n  const encoded = bs10.encode(data);\n  // Strip leading zeros\n  return encoded.replace(/^0*(.)/, \"$1\");\n}\n\nexport function amount_to_buf(amount: string): Buffer {\n  Precondition.checkIsValidAmount(amount);\n\n  const data = bs10.decode(amount);\n  // Amount should fit uin64_t\n  Assert.assert(data.length <= 8);\n\n  const padding = Buffer.alloc(8 - data.length);\n  return Buffer.concat([padding, data]);\n}\n\nexport function base58_encode(data: Buffer): string {\n  Precondition.checkIsBuffer(data);\n\n  return bs58.encode(data);\n}\n\nexport function base58_decode(data: string): Buffer {\n  Precondition.checkIsValidBase58(data);\n\n  return bs58.decode(data);\n}\n\nfunction safe_parseInt(str: string): number {\n  Precondition.checkIsString(str);\n  const i = parseInt(str);\n  // Check that we parsed everything\n  Precondition.check(\"\" + i == str);\n  // Could be invalid\n  Precondition.check(!isNaN(i));\n  // Could still be float\n  Precondition.checkIsInteger(i);\n  return i;\n}\n\nfunction parseBIP32Index(str: string): number {\n  let base = 0;\n  if (str.endsWith(\"'\")) {\n    str = str.slice(0, -1);\n    base = HARDENED;\n  }\n  const i = safe_parseInt(str);\n  Precondition.check(i >= 0);\n  Precondition.check(i < HARDENED);\n  return base + i;\n}\n\nexport function str_to_path(data: string): Array<number> {\n  Precondition.checkIsString(data);\n  Precondition.check(data.length > 0);\n\n  return data.split(\"/\").map(parseBIP32Index);\n}\n\nexport default {\n  HARDENED,\n\n  hex_to_buf,\n  buf_to_hex,\n\n  uint32_to_buf,\n  buf_to_uint32,\n\n  // no pair for now\n  uint8_to_buf,\n\n  // no pair for now\n  path_to_buf,\n\n  amount_to_buf,\n  buf_to_amount,\n\n  base58_encode,\n  base58_decode,\n\n  chunkBy,\n  stripRetcodeFromResponse,\n\n  str_to_path\n};\n"]}