{"version":3,"sources":["../src/Ada.js"],"names":["CLA","INS","GET_VERSION","GET_EXT_PUBLIC_KEY","DERIVE_ADDRESS","ATTEST_UTXO","SIGN_TX","RUN_TESTS","Ada","transport","scrambleKey","methods","decorateAppAPIMethods","_send","p1","p2","data","send","then","stripRetcodeFromResponse","P1_UNUSED","P2_UNUSED","hex_to_buf","response","assert","length","major","minor","patch","txDataHex","outputIndex","checkIsHexString","checkIsUint32","P1_INIT","P1_CONTINUE","CHUNK_SIZE","uint32_to_buf","result","txData","i","chunk","slice","sum","arr","reduce","x","y","sizes","chunkBy","txHash","outputNumber","amount","hmac","rawBuffer","txHashHex","buf_to_hex","buf_to_uint32","amountStr","buf_to_amount","hmacHex","_attestUtxo","path","checkIsValidPath","path_to_buf","publicKey","chainCode","rest","publicKeyHex","toString","chainCodeHex","P1_RETURN","address58","base58_encode","P1_DISPLAY","inputs","outputs","console","log","P1_STAGE_INIT","P1_STAGE_INPUTS","P1_STAGE_OUTPUTS","P1_STAGE_CONFIRM","P1_STAGE_WITNESSES","SIGN_TX_INPUT_TYPE_ATTESTED_UTXO","signTx_init","numInputs","numOutputs","Buffer","concat","signTx_addInput","attestation","uint8_to_buf","signTx_addAddressOutput","amount_to_buf","base58_decode","signTx_addChangeOutput","signTx_awaitConfirm","signTx_getWitness","witnessHex","attestedInputs","push","output","witnesses","input","witness"],"mappings":"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","file":"Ada.js","sourcesContent":["/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// @flow\n\nimport type Transport from \"@ledgerhq/hw-transport\";\nimport { TransportStatusError } from \"@ledgerhq/hw-transport\";\n\nimport utils, { Precondition, Assert } from \"./utils\";\n\nconst CLA = 0xd7;\n\nconst INS = {\n  GET_VERSION: 0x00,\n\n  GET_EXT_PUBLIC_KEY: 0x10,\n  DERIVE_ADDRESS: 0x11,\n\n  ATTEST_UTXO: 0x20,\n  SIGN_TX: 0x21,\n\n  RUN_TESTS: 0xf0\n};\n\ntype BIP32Path = Array<number>;\n\ntype InputTypeUTxO = {|\n  txDataHex: string,\n  outputIndex: number,\n  path: BIP32Path\n|};\n\ntype OutputTypeAddress = {|\n  amountStr: string,\n  address58: string\n|};\n\ntype OutputTypeChange = {|\n  amountStr: string,\n  path: BIP32Path\n|};\n\n/**\n * Cardano ADA API\n *\n * @example\n * import Ada from \"@ledgerhq/hw-app-ada\";\n * const ada = new Ada(transport);\n */\nexport default class Ada {\n  transport: Transport<*>;\n  methods: Array<string>;\n\n  constructor(transport: Transport<*>, scrambleKey: string = \"ADA\") {\n    this.transport = transport;\n    this.methods = [\n      \"getVersion\",\n      \"getExtendedPublicKey\",\n      \"signTransaction\",\n      \"deriveAddress\"\n    ];\n    this.transport.decorateAppAPIMethods(this, this.methods, scrambleKey);\n  }\n\n  /**\n   * Returns an object containing the app version.\n   *\n   * @returns {Promise<{major:number, minor:number, patch:number}>} Result object containing the application version number.\n   *\n   * @example\n   * const { major, minor, patch } = await ada.getVersion();\n   * console.log(`App version ${major}.${minor}.${patch}`);\n   *\n   */\n  async getVersion(): Promise<{\n    major: string,\n    minor: string,\n    patch: string\n  }> {\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.GET_VERSION, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_UNUSED = 0x00;\n    const P2_UNUSED = 0x00;\n    const response = await _send(P1_UNUSED, P2_UNUSED, utils.hex_to_buf(\"\"));\n    Assert.assert(response.length == 3);\n    const [major, minor, patch] = response;\n    return { major, minor, patch };\n  }\n\n  /**\n   * Runs unit tests on the device (DEVEL app build only)\n   *\n   * @returns {Promise<void>}\n   */\n  async runTests(): Promise<void> {\n    await this.transport.send(CLA, INS.RUN_TESTS, 0x00, 0x00);\n  }\n\n  async _attestUtxo(\n    txDataHex: string,\n    outputIndex: number\n  ): Promise<{\n    txHashHex: string,\n    outputIndex: number,\n    amountStr: string,\n    hmacHex: string,\n    rawBuffer: Buffer\n  }> {\n    Precondition.checkIsHexString(txDataHex);\n    Precondition.checkIsUint32(outputIndex);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.ATTEST_UTXO, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_INIT = 0x01;\n    const P1_CONTINUE = 0x02;\n\n    const P2_UNUSED = 0x00;\n\n    const CHUNK_SIZE = 255;\n\n    {\n      // Initial request\n      const data = utils.uint32_to_buf(outputIndex);\n      const result = await _send(P1_INIT, P2_UNUSED, data);\n      Assert.assert(result.length == 0);\n    }\n\n    const txData = utils.hex_to_buf(txDataHex);\n\n    let i = 0;\n    {\n      // middle requests\n      while (i + CHUNK_SIZE < txData.length) {\n        const chunk = txData.slice(i, i + CHUNK_SIZE);\n        const result = await _send(P1_CONTINUE, P2_UNUSED, chunk);\n        Assert.assert(result.length == 0);\n        i += CHUNK_SIZE;\n      }\n    }\n\n    // final request\n    {\n      const chunk = txData.slice(i);\n      const result = await _send(P1_CONTINUE, P2_UNUSED, chunk);\n\n      const sum = arr => arr.reduce((x, y) => x + y, 0);\n\n      const sizes = [32, 4, 8, 16];\n      Assert.assert(result.length == sum(sizes));\n\n      const [txHash, outputNumber, amount, hmac] = utils.chunkBy(result, sizes);\n\n      return {\n        rawBuffer: result,\n        txHashHex: utils.buf_to_hex(txHash),\n        outputIndex: utils.buf_to_uint32(outputNumber),\n        amountStr: utils.buf_to_amount(amount),\n        hmacHex: utils.buf_to_hex(hmac)\n      };\n    }\n  }\n\n  /**\n   * @param string Raw transaction data (without witnesses) encoded as hex string\n   * @param number Output indes\n   *\n   */\n  async attestUtxo(\n    txDataHex: string,\n    outputIndex: number\n  ): Promise<{\n    txHashHex: string,\n    outputIndex: number,\n    amountStr: string,\n    hmacHex: string,\n    rawBuffer: Buffer\n  }> {\n    return this._attestUtxo(txDataHex, outputIndex);\n  }\n\n  /**\n   * @description Get a public key from the specified BIP 32 path.\n   *\n   * @param {Array<number>} indexes The path indexes. Path must begin with `44'/1815'/n'`, and may be up to 10 indexes long.\n   * @return {Promise<{ publicKey:string, chainCode:string }>} The public key with chaincode for the given path.\n   *\n   * @example\n   * const { publicKey, chainCode } = await ada.getExtendedPublicKey([ HARDENED + 44, HARDENED + 1815, HARDENED + 1 ]);\n   * console.log(publicKey);\n   *\n   */\n  async getExtendedPublicKey(\n    path: BIP32Path\n  ): Promise<{ publicKeyHex: string, chainCodeHex: string }> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.GET_EXT_PUBLIC_KEY, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_UNUSED = 0x00;\n    const P2_UNUSED = 0x00;\n\n    const data = utils.path_to_buf(path);\n\n    const response = await _send(P1_UNUSED, P2_UNUSED, data);\n\n    const [publicKey, chainCode, rest] = utils.chunkBy(response, [32, 32]);\n    Assert.assert(rest.length == 0);\n\n    return {\n      publicKeyHex: publicKey.toString(\"hex\"),\n      chainCodeHex: chainCode.toString(\"hex\")\n    };\n  }\n\n  /**\n   * @description Gets an address from the specified BIP 32 path.\n   *\n   * @param {Array<number>} indexes The path indexes. Path must begin with `44'/1815'/i'/(0 or 1)/j`, and may be up to 10 indexes long.\n   * @return {Promise<{ address:string }>} The address for the given path.\n   *\n   * @throws 5001 - The path provided does not have the first 3 indexes hardened or 4th index is not 0 or 1\n   * @throws 5002 - The path provided is less than 5 indexes\n   * @throws 5003 - Some of the indexes is not a number\n   *\n   * @example\n   * const { address } = await ada.deriveAddress([ HARDENED + 44, HARDENED + 1815, HARDENED + 1, 0, 5 ]);\n   *\n   */\n  async deriveAddress(path: BIP32Path): Promise<{ address58: string }> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.DERIVE_ADDRESS, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_RETURN = 0x01;\n    const P2_UNUSED = 0x00;\n    const data = utils.path_to_buf(path);\n    const response = await _send(P1_RETURN, P2_UNUSED, data);\n\n    return {\n      address58: utils.base58_encode(response)\n    };\n  }\n\n  async showAddress(path: BIP32Path): Promise<void> {\n    Precondition.checkIsValidPath(path);\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.DERIVE_ADDRESS, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const P1_DISPLAY = 0x02;\n    const P2_UNUSED = 0x00;\n    const data = utils.path_to_buf(path);\n    const response = await _send(P1_DISPLAY, P2_UNUSED, data);\n    Assert.assert(response.length == 0);\n  }\n\n  async signTransaction(\n    inputs: Array<InputTypeUTxO>,\n    outputs: Array<OutputTypeAddress | OutputTypeChange>\n  ) {\n    console.log(\"sign\");\n\n    const P1_STAGE_INIT = 0x01;\n    const P1_STAGE_INPUTS = 0x02;\n    const P1_STAGE_OUTPUTS = 0x03;\n    const P1_STAGE_CONFIRM = 0x04;\n    const P1_STAGE_WITNESSES = 0x05;\n    const P2_UNUSED = 0x00;\n    const SIGN_TX_INPUT_TYPE_ATTESTED_UTXO = 0x01;\n\n    const _send = (p1, p2, data) =>\n      this.transport\n        .send(CLA, INS.SIGN_TX, p1, p2, data)\n        .then(utils.stripRetcodeFromResponse);\n\n    const signTx_init = async (\n      numInputs: number,\n      numOutputs: number\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.uint32_to_buf(numInputs),\n        utils.uint32_to_buf(numOutputs)\n      ]);\n      const response = await _send(P1_STAGE_INIT, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addInput = async (attestation): Promise<void> => {\n      const data = Buffer.concat([\n        utils.uint8_to_buf(SIGN_TX_INPUT_TYPE_ATTESTED_UTXO),\n        attestation.rawBuffer\n      ]);\n      const response = await _send(P1_STAGE_INPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addAddressOutput = async (\n      address58: string,\n      amountStr: string\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.amount_to_buf(amountStr),\n        utils.uint8_to_buf(0x01),\n        utils.base58_decode(address58)\n      ]);\n      const response = await _send(P1_STAGE_OUTPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_addChangeOutput = async (\n      path: BIP32Path,\n      amountStr: string\n    ): Promise<void> => {\n      const data = Buffer.concat([\n        utils.amount_to_buf(amountStr),\n        utils.uint8_to_buf(0x02),\n        utils.path_to_buf(path)\n      ]);\n      const response = await _send(P1_STAGE_OUTPUTS, P2_UNUSED, data);\n      Assert.assert(response.length == 0);\n    };\n\n    const signTx_awaitConfirm = async (): Promise<{\n      txHashHex: string\n    }> => {\n      const response = await _send(\n        P1_STAGE_CONFIRM,\n        P2_UNUSED,\n        utils.hex_to_buf(\"\")\n      );\n      return {\n        txHashHex: response.toString(\"hex\")\n      };\n    };\n\n    const signTx_getWitness = async (\n      path: BIP32Path\n    ): Promise<{\n      path: BIP32Path,\n      witnessHex: string\n    }> => {\n      const data = Buffer.concat([utils.path_to_buf(path)]);\n      const response = await _send(P1_STAGE_WITNESSES, P2_UNUSED, data);\n      return {\n        path: path,\n        witnessHex: utils.buf_to_hex(response)\n      };\n    };\n\n    console.log(\"attest\");\n    const attestedInputs = [];\n    // attest\n    for (const { txDataHex, outputIndex } of inputs) {\n      const attestation = await this._attestUtxo(txDataHex, outputIndex);\n      attestedInputs.push(attestation);\n    }\n\n    // init\n    console.log(\"init\");\n    await signTx_init(attestedInputs.length, outputs.length);\n\n    // inputs\n    console.log(\"inputs\");\n    for (const attestation of attestedInputs) {\n      await signTx_addInput(attestation);\n    }\n\n    // outputs\n    console.log(\"outputs\");\n    for (const output of outputs) {\n      if (output.address58) {\n        await signTx_addAddressOutput(output.address58, output.amountStr);\n      } else if (output.path) {\n        await signTx_addChangeOutput(output.path, output.amountStr);\n      } else {\n        throw \"TODO\";\n      }\n    }\n\n    // confirm\n    console.log(\"confirm\");\n    const { txHashHex } = await signTx_awaitConfirm();\n\n    console.log(\"witnesses\");\n    const witnesses = [];\n    for (const input of inputs) {\n      const witness = await signTx_getWitness(input.path);\n      witnesses.push(witness);\n    }\n    return {\n      txHashHex,\n      witnesses\n    };\n  }\n}\n"]}